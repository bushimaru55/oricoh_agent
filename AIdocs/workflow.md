# 業務フロー仕様書

## 概要

oricoh_agentの主要な業務フローを定義します。各フローはマルチテナント対応で、セキュリティを最優先とします。

---

## 1. ユーザーログインフロー

### 概要
ユーザーがシステムにログインし、JWTトークンを取得するフローです。

### 参加者
- ユーザー
- フロントエンド（Next.js）
- バックエンド（Django）

### フロー図
```
[ユーザー] → [ログイン画面] → [認証API] → [JWT発行] → [チャット画面]
```

### 詳細ステップ

1. **ユーザーがログイン画面にアクセス**
   - URL: `/login`
   - 認証: 不要

2. **ユーザーが認証情報を入力**
   - ユーザー名（またはメールアドレス）
   - パスワード

3. **フロントエンドがバリデーション**
   - ユーザー名: 最小3文字
   - パスワード: 最小8文字

4. **フロントエンドが認証APIを呼び出し**
   - エンドポイント: `POST /api/auth/login`
   - リクエストボディ: `{username, password}`

5. **バックエンドが認証処理**
   - ユーザー名でユーザーを検索
   - パスワードハッシュを検証
   - ユーザーの`org_id`を取得

6. **バックエンドがJWTを発行**
   - ペイロード: `{user_id, org_id, username, exp}`
   - 有効期限: 24時間

7. **フロントエンドがJWTを保存**
   - ローカルストレージに保存
   - 以降のAPIリクエストに含める

8. **フロントエンドがチャット画面にリダイレクト**
   - URL: `/chat`

### エラーハンドリング
- 認証失敗: エラーメッセージを表示
- ネットワークエラー: エラーメッセージを表示、リトライ可能

---

## 2. 文書アップロード・処理フロー

### 概要
ユーザーが文書をアップロードし、マルチモーダル解析・チャンク分割・Embedding生成まで行うフローです。

### 参加者
- ユーザー
- フロントエンド
- バックエンド
- OpenAI API
- SQLite Vector

### フロー図
```
[ユーザー] → [アップロード] → [ファイル保存] → [解析開始] → [チャンク分割] → [Embedding生成] → [ベクトルDB保存] → [完了通知]
```

### 詳細ステップ

#### 2.1 アップロードフェーズ

1. **ユーザーがファイルを選択**
   - ドラッグ&ドロップまたはファイル選択ダイアログ
   - 対応形式: PDF, DOCX, XLSX, PPTX, JPG, PNG, GIF

2. **フロントエンドがバリデーション**
   - ファイル形式チェック
   - ファイルサイズチェック（最大100MB）
   - ファイル数チェック（最大10ファイル）

3. **フロントエンドがアップロードAPIを呼び出し**
   - エンドポイント: `POST /api/document/upload`
   - Content-Type: `multipart/form-data`
   - ヘッダー: `Authorization: Bearer <token>`

4. **バックエンドがJWTを検証**
   - トークンの有効性確認
   - `org_id`を取得

5. **バックエンドがファイルを保存**
   - 保存先: `/storage/{org_id}/{filename}`
   - Documentレコード作成（status: "pending"）

6. **バックエンドが即座にレスポンス**
   - Document IDを返す
   - status: "processing"

#### 2.2 バックグラウンド処理フェーズ

7. **バックグラウンドタスクが開始**
   - Celery等の非同期タスクキューを使用
   - Document.statusを"processing"に更新

8. **ファイル形式に応じた前処理**
   - PDF: ページごとに画像化（必要に応じて）
   - Office: テキスト抽出
   - 画像: そのまま使用

9. **マルチモーダル解析**
   - GPT-4oまたはo1-previewを使用
   - 画像・表・図を含む構造化抽出
   - Markdown形式で出力

10. **チャンク分割**
    - 意味単位で分割（2000-2500文字）
    - H1/H2/H3見出し単位
    - 表はMarkdown形式で保持
    - Chunkレコード作成（各チャンクごと）

11. **Embedding生成**
    - embedding-3-largeを使用
    - 各チャンクをベクトル化（3072次元）
    - Embeddingレコード作成
    - SQLite Vectorに保存（メタデータに`org_id`, `document_id`, `chunk_id`を含める）

12. **処理完了**
    - Document.statusを"completed"に更新
    - エラー時は"failed"に更新、エラーメッセージを記録

#### 2.3 通知フェーズ

13. **フロントエンドがステータスをポーリング**
    - エンドポイント: `GET /api/document/{id}`
    - 定期的にステータスを確認（5秒間隔）

14. **完了通知**
    - ステータスが"completed"になったら通知
    - またはWebSocketでリアルタイム通知

### エラーハンドリング
- ファイル形式エラー: エラーメッセージを表示、アップロード拒否
- ファイルサイズ超過: エラーメッセージを表示、アップロード拒否
- 解析エラー: Document.statusを"failed"に更新、エラーメッセージを記録
- OpenAI APIエラー: リトライロジック（最大3回）

---

## 3. RAG検索・回答生成フロー

### 概要
ユーザーの質問に対して、RAG検索を実行し、AI回答を生成するフローです。

### 参加者
- ユーザー
- フロントエンド
- バックエンド
- OpenAI API（embedding-3-large, GPT-4.1）
- SQLite Vector

### フロー図
```
[ユーザー質問] → [質問ベクトル化] → [ベクトル検索] → [チャンク取得] → [AI回答生成] → [回答表示]
```

### 詳細ステップ

1. **ユーザーが質問を入力**
   - チャット画面で質問を入力
   - 最大2000文字

2. **フロントエンドがバリデーション**
   - 空文字チェック
   - 文字数チェック

3. **フロントエンドがチャットAPIを呼び出し**
   - エンドポイント: `POST /api/chat/query`
   - リクエストボディ: `{question, model, max_results, temperature}`
   - ヘッダー: `Authorization: Bearer <token>`

4. **バックエンドがJWTを検証**
   - トークンの有効性確認
   - `org_id`を取得

5. **バックエンドが質問をベクトル化**
   - embedding-3-largeを使用
   - 3072次元のベクトルを生成

6. **バックエンドがベクトル検索を実行**
   - SQLite Vectorで類似度検索
   - `org_id`でフィルタ（他組織のデータは検索対象外）
   - 上位N件（デフォルト: 5件）を取得
   - 類似度スコアを計算

7. **バックエンドがチャンク情報を取得**
   - 検索結果のチャンクIDからChunkレコードを取得
   - 関連するDocument情報も取得

8. **バックエンドがAI回答を生成**
   - GPT-4.1またはo1-miniを使用
   - プロンプト: 質問 + 検索結果のチャンク（コンテキスト）
   - 温度パラメータ: 0.7（デフォルト）
   - 回答を生成

9. **バックエンドがcitationsを生成**
   - 検索結果のチャンク情報からcitationsを構築
   - 各citationに含める情報:
     - chunk_id
     - document_id
     - document_name
     - chunk_text（最初の200文字）
     - score（類似度）
     - page_number（該当する場合）

10. **バックエンドがChatLogを保存**
    - 質問、回答、citations、モデル名、トークン数、応答時間を記録

11. **バックエンドがレスポンスを返す**
    - 回答、citations、メタデータ（モデル名、トークン数、応答時間）

12. **フロントエンドが回答を表示**
    - 回答をマークダウン形式で表示
    - citationsを回答の下に表示
    - チャット履歴に追加

### エラーハンドリング
- ベクトル検索結果なし: 回答を生成せず、メッセージを表示
- OpenAI APIエラー: エラーメッセージを表示、リトライ可能
- タイムアウト: エラーメッセージを表示

---

## 4. Microsoft365同期フロー

### 概要
Microsoft365（SharePoint/OneDrive）から文書を自動同期するフローです。

### 参加者
- ユーザー
- フロントエンド
- バックエンド
- Microsoft Graph API
- OpenAI API
- SQLite Vector

### フロー図
```
[同期開始] → [Graph API認証] → [ファイル一覧取得] → [差分検出] → [アップロード処理] → [完了通知]
```

### 詳細ステップ

#### 4.1 初期設定フェーズ

1. **ユーザーがMicrosoft365設定画面にアクセス**
   - URL: `/settings`
   - Microsoft365設定タブを選択

2. **ユーザーが接続ボタンをクリック**
   - Microsoft OAuth認証フローを開始

3. **Microsoft認証**
   - Azure AD認証ページにリダイレクト
   - ユーザーが認証・承認
   - 認証コードを取得

4. **バックエンドがトークンを取得**
   - 認証コードをアクセストークン・リフレッシュトークンに交換
   - Microsoft365Connectionレコード作成
   - トークンを暗号化して保存

#### 4.2 同期実行フェーズ

5. **ユーザーが同期を開始**
   - 同期フォルダパスを指定
   - 再帰的同期の有無を選択
   - 同期ボタンをクリック

6. **バックエンドが同期APIを呼び出し**
   - エンドポイント: `POST /api/document/microsoft365/sync`
   - リクエストボディ: `{folder_path, recursive}`

7. **バックエンドがMicrosoft Graph APIでファイル一覧を取得**
   - リフレッシュトークンでアクセストークンを更新（必要に応じて）
   - Graph API: `GET /sites/{site-id}/drive/root:/{folder-path}:/children`
   - 再帰的同期の場合はサブフォルダも取得

8. **バックエンドが差分を検出**
   - 既存のDocumentレコードと比較（source_idで照合）
   - 新規ファイル・更新ファイルを特定

9. **バックエンドが各ファイルを処理**
   - ファイルをダウンロード
   - `/api/document/upload`と同様の処理フローを実行
   - source: "microsoft365"
   - source_id: Microsoft365のitem_id

10. **バックエンドが同期完了を記録**
    - Microsoft365Connection.last_sync_atを更新

11. **フロントエンドが完了通知を表示**
    - 同期されたファイル数を表示

### エラーハンドリング
- Microsoft認証エラー: エラーメッセージを表示、再認証を促す
- Graph APIエラー: エラーメッセージを表示、リトライ可能
- ファイルダウンロードエラー: エラーメッセージを記録、次のファイルへ

---

## 5. チャット履歴閲覧フロー

### 概要
ユーザーが過去のチャット履歴を閲覧するフローです。

### 参加者
- ユーザー
- フロントエンド
- バックエンド

### 詳細ステップ

1. **ユーザーがチャット画面にアクセス**
   - URL: `/chat`
   - サイドバーに履歴一覧が表示される

2. **フロントエンドが履歴APIを呼び出し**
   - エンドポイント: `GET /api/chat/history`
   - Query Parameters: `page, page_size, start_date, end_date`

3. **バックエンドがJWTを検証**
   - トークンの有効性確認
   - `org_id`を取得

4. **バックエンドが履歴を取得**
   - ChatLog.objects.filter(org=org_id, user=user_id)
   - 日時でソート（新しい順）
   - ページネーション

5. **バックエンドがレスポンスを返す**
   - 履歴一覧（質問、回答の最初の100文字、作成日時）

6. **フロントエンドが履歴を表示**
   - サイドバーに履歴一覧を表示
   - 各履歴は質問の最初の50文字を表示

7. **ユーザーが履歴をクリック**
   - 詳細APIを呼び出し: `GET /api/chat/history/{id}`
   - 完全な質問・回答・citationsを取得
   - チャットエリアに表示

---

## 6. 文書削除フロー

### 概要
ユーザーが文書を削除するフローです。関連するチャンク・Embeddingも削除されます。

### 参加者
- ユーザー
- フロントエンド
- バックエンド
- SQLite Vector

### 詳細ステップ

1. **ユーザーが文書一覧画面にアクセス**
   - URL: `/documents`

2. **ユーザーが削除ボタンをクリック**
   - 文書カード/行の削除ボタン

3. **フロントエンドが確認ダイアログを表示**
   - 「この文書を削除しますか？」メッセージ
   - 確認・キャンセルボタン

4. **ユーザーが確認**
   - 確認ボタンをクリック

5. **フロントエンドが削除APIを呼び出し**
   - エンドポイント: `DELETE /api/document/{id}`
   - ヘッダー: `Authorization: Bearer <token>`

6. **バックエンドがJWTを検証**
   - トークンの有効性確認
   - `org_id`を取得

7. **バックエンドが文書の所有権を確認**
   - Document.objects.filter(id=id, org=org_id).exists()
   - 他組織の文書の場合は404エラー

8. **バックエンドが関連データを削除**
   - 関連するChunkレコードを削除
   - 関連するEmbeddingレコードを削除
   - SQLite Vectorからベクトルを削除
   - ファイルをストレージから削除
   - Documentレコードを削除

9. **バックエンドがレスポンスを返す**
   - 成功メッセージ

10. **フロントエンドが一覧を更新**
    - 削除された文書を一覧から除外
    - または一覧を再取得

---

## セキュリティ考慮事項

### マルチテナント分離
- すべてのクエリで`org_id`でフィルタ
- JWTに`org_id`を含め、バックエンドで検証
- ストレージも組織ごとに分離

### 認証・認可
- JWTの有効期限管理
- トークンリフレッシュ機能
- ログアウト時のトークン無効化（オプション）

### データ保護
- パスワードはハッシュ化（bcrypt等）
- Microsoft365トークンは暗号化
- ファイルは組織ごとに分離保存

---

## 変更履歴

| 日付 | 変更内容 | 変更理由 |
|------|---------|---------|
| 2024-XX-XX | 初版作成 | プロジェクト開始 |

